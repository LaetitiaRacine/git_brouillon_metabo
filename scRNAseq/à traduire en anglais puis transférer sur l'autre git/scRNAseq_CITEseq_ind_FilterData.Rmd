---
title: "scRNAseq_CITEseq_ind_FilterData"
author: "Laëtitia Racine"
date: "06/12/2021"
subtitle: "Dernière modification : `r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: "show"
    toc: false
    theme: journal
---

<style>
body {text-align: justify}
</style>

```{r, Setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, Dependencies, message=F, warning=F}

library(Seurat)
library(dplyr)
library(ggplot2)
library(kableExtra)
library(gridExtra)
library(grid) # function textGrob()

```

Ce code **permet de** :      
- filtrer les cellules sur la base du nombre de gènes détectés    
- filtrer les cellules sr la base de leur pourcentage d'ARN mitochondrial    
- filtrer les cellules sur la base de leur pourcentage d'ARN ribosomal    
- filtrer les gènes pour enlever les gènes mitochondriaux     
- créer un tableau récapitulatif indiquant le nombre de cellules et gènes écartés par chaque filtre    
  
Il est **inspiré** de :     
- https://satijalab.org/seurat/articles/pbmc3k_tutorial.html     
- https://nbisweden.github.io/workshop-scRNAseq/labs/compiled/seurat/seurat_01_qc.html     
    
On obtient **en sortie** un objet Seurat après chaque filtre (sachant que les filtres sont cumulatifs, si on veut appliquer un seul filtre, il faut le faire à la main et enregistrer) ainsi qu'un tableau récapitulatif de l'effet des filtres.

```{r, Working directories and external script}

# Load working directories
directory = "/home/rparmentier/Bureau/Git_Metabo_Analysis/"
directory_exp = paste0(directory, "exp/")
directory_data = paste0(directory, "data/scRNAseq/")
directory_bin = paste0(directory, "bin/")

# Create a unique folder for output corresponding to the date of the day
current_date = format(Sys.time(), "%Y%m%d")
dir.create(path = paste0(directory_exp,"scRNAseq_CITEseq_ind_FilterData/"))
dir.create(path = paste0(directory_exp,"scRNAseq_CITEseq_ind_FilterData/", current_date))
directory_output = paste0(directory_exp, "scRNAseq_CITEseq_ind_FilterData/", current_date, "/")

# Load external script with functions and constantes 
source(file = paste0(directory_bin, "functions_constantes.R"))

```

```{r, Input loading and output initializing}

# Load seurat objects
dir = pic_last_dir(paste0(directory_exp, "scRNAseq_CITEseq_ind_CreateSeuratObject/"))
list_seurat_obj = readRDS(paste0(dir, "/", "list_seurat_obj.rds"))
number_conditions = length(list_seurat_obj)

# Initialize empty list for output
filtered_list_seurat_obj = list()

# Initialize a list of list to store all versions of seurat object (different filter levels)
list_seurat_obj_filter = list()
for(i in 1:length(list_seurat_obj)) { list_seurat_obj_filter[[i]] = list()}
names(list_seurat_obj_filter) = names(list_seurat_obj)

```

list_seurat_obj => document initial sans filtre appliqué
list_seurat_obj_filter => objet dans lequel sont stockées tous les objets intermédiaires filtrés 
filtered_seurat_obj => list_seurat_obj sur lequel ont été appliqués les filtres en cumulatif


# Application de filtres Qualité CUMULATIFS sur les données 



## Filtre_nbG : les cellules conservées ont **entre 1000 et 6500 gènes détectés**

Les cellules dans lesquelles il y a très peu de gènes détectés peuvent correpondre à des biais de technique. On décide donc d'appliquer un filtre sur le nombre minimum de gènes détectés pour être considéré comme une vraie cellule de bonne qualité. De la même façon, les cellules qui semblent avoir beaucoup plus de gènes détectés par rapport aux autres cellules de l'expérience peuvent correspondre à des doublets. On applique donc deux seuils pour garder les cellules les plus qualitatives. Pour savoir où les placer, on observe de plus près le nombre de gènes détectés par cellules en fonction des conditions.

```{r, Number of genes detected per cell, message=F, results='hold', fig.width=16, fig.height=10}

# Initialize list of graphs 
plot_feature_graphs = list()

# Loop to create features_RNA graphs and store them into the list
for (i in 1:number_conditions) {

  plot_feature = VlnPlot(list_seurat_obj[[i]], features = "nFeature_RNA") + 
    geom_hline(aes(yintercept = 6500), color = "red", size = 1) +
    geom_hline(aes(yintercept = 1000), color = "red", size = 1) +
    stat_summary(fun = median, geom='point', size = 5 , colour = "white") +
    ylim(0,8000) +
    scale_fill_manual(values = color_code, limits = force) +
    theme(axis.title.x = element_blank(),
          plot.title = element_blank()) +
    NoLegend() 
 
  plot_feature_graphs[[i]] = plot_feature
  
}

# Show graphs
grid.arrange(grobs = plot_feature_graphs,
             ncol = 5,
             nrow = 2,
             top = textGrob("nFeature_RNA"))

```

En se basant sur ces graphiques, on peut établir des seuils "à l'oeil". On décide ainsi d'enlever toutes les cellules avec moins de *1000 gènes et toutes celles avec plus de 6500 gènes*. La médiane des gènes détectés par cellule se situant entre 2731 et 3880 selon les conditions (cf. résultats websummary cellRanger), les limites appliquées semblent cohérentes. On peut se permettre d'être restrictif à ce niveau car on ne cherche pas de population rare. => **filtre_nbG**

```{r, Filter_nbG, warning=F, message=F}

for (i in 1:number_conditions) {
  
  # Apply filter on cell depending on their genes number 
  filtered_list_seurat_obj[[i]] = subset(list_seurat_obj[[i]], subset = 1000 < nFeature_RNA & nFeature_RNA < 6500)
  filtered_list_seurat_obj[[i]][["filter_nbG"]] = "1000<nFeatures>6500"
  
  # Save seurat object with nbG filter
  list_seurat_obj_filter[[i]]["seurat_obj_nbG"] = filtered_list_seurat_obj[[i]] 
  
}

```




## Filtre_pMT et Filtre_pRB : les cellules conservées ont **moins de 25% d'ARN mitochondrial** et **plus de 5% d'ARN ribosomal**

```{r, Percentages RNA, message=F, warning=F, fig.width=16, fig.height=20, fig.fullwidth=TRUE}

ARN_percentage_fun = function(obj) {
  
  # Extraction de la liste des gènes mitochondriaux et ribosomaux
  mito_genes = rownames(obj)[grep("^MT-", rownames(obj))]
  ribo_genes <- rownames(obj)[grep("^RP[SL]", rownames(obj))]
  cat("\n", "Mitochondrial genes", length(mito_genes), ":", mito_genes, "\n")
  cat("Ribosomal genes", length(ribo_genes), ":", ribo_genes, "\n")

  # Ajout du pourcentage dans l'objet seurat
  obj[["percent.mt"]] <- PercentageFeatureSet(obj, pattern = "^MT-")
  obj[["percent.ribo"]] <- PercentageFeatureSet(obj, pattern = "^RP[SL]")

  # Output 
  return(obj)
  
}

plot_percentage_graphs = list()

for (i in 1:number_conditions) {
  
  # Calculate percentage of mitochondrial and ribosomal RNA
  filtered_list_seurat_obj[[i]] = ARN_percentage_fun(filtered_list_seurat_obj[[i]])
  
  p1 = VlnPlot(filtered_list_seurat_obj[[i]], features = "percent.mt", group.by = "orig.ident") +
    geom_hline(aes(yintercept = 25), color = "red", size = 1) +
    ylim(0,100)  +
    scale_fill_manual(values = color_code, limits = force) +
    theme(axis.title.x = element_blank()) +
    NoLegend()

  p2 = VlnPlot(filtered_list_seurat_obj[[i]], features = "percent.ribo", group.by = "orig.ident") +
    geom_hline(aes(yintercept = 5), color = "red", size = 1) +
    ylim(0,100) +
    scale_fill_manual(values = color_code, limits = force) +
    theme(axis.title.x = element_blank()) +
    NoLegend()

  p3 = FeatureScatter(filtered_list_seurat_obj[[i]], feature1 = "percent.mt", feature2 = "percent.ribo", group.by = "orig.ident") +
    ylim(0,100) +
    scale_color_manual(values = color_code, limits = force) +
    annotate("rect", xmin = 0, xmax = 25, ymin = 5, ymax = 60, alpha = 0.1, color = "red")
  
  plot_percentage_graphs[[i]] = list(p1, p2, p3)
  
}

# Show graphs
grid.arrange(grobs = unlist(plot_percentage_graphs, recursive = FALSE),
             ncol = 6,
             top = textGrob("Mitochondrial and ribosomal RNA percentages"))

```

Les cellules présentant un fort pourcentage d'ARN mitochondrial et un faible pourcentage d'ARN ribosomal sont certainement mortes ou en train de mourir. On remarque en effet deux groupes de cellules lorsqu'on trace le scatter plot percent.ribo vs percent.mt : un groupe de cellules à gauche avec un faible pourcentage d'ARN mitochondrial et un pourcentage d'ARN ribosomal allant d'environ 10 à plus de 50% correspondant aux cellules vivantes, et un groupe de cellules à droite avec un fort pourcentage d'ARN mitochondrial et un faible pourcentage d'ARN ribosomal. Pour enlever le maximum de cellules mortes tout en gardant suffisamment d'informations, on applique des filtres sur ces deux paramètres : on conserve ainsi les cellules avec **moins de 25% d'ARN mitochondrial** (**Filtre_pMT**) et avec **plus de 5% d'ARN ribosomal** (**Filtre_pRB**).

```{r, Filter_pMT_pRB, warning=F, message=F}

for (i in 1:number_conditions) {
  
  # Apply filter on cell depending on their percentage of mitochondrial RNA
  filtered_list_seurat_obj[[i]] = subset(filtered_list_seurat_obj[[i]], subset = percent.mt < 25)
  filtered_list_seurat_obj[[i]][["filter_pMT"]] = "< 25% MT" 
  
  # Save seurat object with nbG and pMT filters
  list_seurat_obj_filter[[i]]["seurat_obj_nbG_pMT"] = filtered_list_seurat_obj[[i]] 
  
  # Apply filter on cell depending on their percentage of ribosomal RNA 
  filtered_list_seurat_obj[[i]] = subset(filtered_list_seurat_obj[[i]], subset = percent.ribo > 5)
  filtered_list_seurat_obj[[i]][["filter_pRB"]] = "> 5% RB"  
  
  # Save seurat object with nbG, pMT and pRB filters
  list_seurat_obj_filter[[i]]["seurat_obj_nbG_pMT_pRB"] = filtered_list_seurat_obj[[i]] 
  
}

```





## Filtre_rmMT : les gènes **mitochondriaux** sont retirés de l'analyse

Pour éviter que les cellules ne clusterisent sur la base de leurs gènes mitochondriaux, on décide de les retirer de l'analyse. => **Filtre_rmMT**  

```{r, Filter_rmMT, warning=F, message=F}

rm_mito_list = function(obj) {
  # Extraction des noms des features pour ADT
  DefaultAssay(obj) = "ADT"
  feature_adt_list = rownames(obj)
  # Extraction de tous les noms des gènes pour RNA et aussi distinction pour les gènes mitochondriaux
  DefaultAssay(obj) = "RNA"
  mito_genes = rownames(obj)[grep("^MT-", rownames(obj))]
  feature_rna_list = rownames(obj)
  # Groupement des listes et on conserve seulement les features qui ne matchent pas avec la liste des gènes mitochondriaux
  feature_list = c(feature_adt_list, feature_rna_list)
  features_keep = setdiff(feature_list, mito_genes) # The elements of setdiff(x,y) are those elements in x but not in y.
  return(features_keep)
}


for (i in 1:number_conditions) {
  
  # Apply filter on genes to remove mitochondrial ones
  filtered_list_seurat_obj[[i]] = subset(filtered_list_seurat_obj[[i]], features = rm_mito_list(filtered_list_seurat_obj[[i]]))
  filtered_list_seurat_obj[[i]][["filter_rmMT"]] = "rm MTgenes" 
  
  # Save seurat object with nbG, pMT, pRB and rmMT filters
  list_seurat_obj_filter[[i]]["seurat_obj_nbG_pMT_pRB_rmMT"] = filtered_list_seurat_obj[[i]] 
  
}

```




# Récapitulatif du nombre de celluels et gènes dans chaque condition

## Tableau récapitulatif des filtres appliqués 

```{r}

extract_nbgene_detected = function(obj) {
  matrix = as.data.frame(obj@assays$RNA@counts)
  sum_UMI = as.data.frame(rowSums(matrix))
  detected_genes = sum_UMI %>% dplyr::filter(`rowSums(matrix)` != 0)
  return(nrow(detected_genes))
}

# Initialize
filter_tab = data_frame(condition = character(),
                 category = character(),
                 no_filter = integer(),
                 filter_nbG_keep = integer(),
                 filter_nbG_pMT_keep = integer(),
                 filter_nbG_pMT_pRB_keep = integer(),
                 filter_nbG_pMT_pRB_rmMT_keep = integer())
  
for(i in 1:number_conditions) {  # très long

  temp_gene = data.frame(condition = names(list_seurat_obj[i]),
                        category = "genes",
                        no_filter = extract_nbgene_detected(list_seurat_obj[[i]]),
                        filter_nbG_keep = extract_nbgene_detected(list_seurat_obj_filter[[i]][["seurat_obj_nbG"]]),
                        filter_nbG_pMT_keep = extract_nbgene_detected(list_seurat_obj_filter[[i]][["seurat_obj_nbG_pMT"]]),
                        filter_nbG_pMT_pRB_keep = extract_nbgene_detected(list_seurat_obj_filter[[i]][["seurat_obj_nbG_pMT_pRB"]]),
                        filter_nbG_pMT_pRB_rmMT_keep = extract_nbgene_detected(list_seurat_obj_filter[[i]][["seurat_obj_nbG_pMT_pRB_rmMT"]]))
  
    temp_cell = data.frame(condition = names(list_seurat_obj[i]),
                          category = "cells",
                          no_filter = ncol(list_seurat_obj[[i]]),
                          filter_nbG_keep = ncol(list_seurat_obj_filter[[i]][["seurat_obj_nbG"]]),
                          filter_nbG_pMT_keep = ncol(list_seurat_obj_filter[[i]][["seurat_obj_nbG_pMT"]]),
                          filter_nbG_pMT_pRB_keep = ncol(list_seurat_obj_filter[[i]][["seurat_obj_nbG_pMT_pRB"]]),
                          filter_nbG_pMT_pRB_rmMT_keep = ncol(list_seurat_obj_filter[[i]][["seurat_obj_nbG_pMT_pRB_rmMT"]]))
  
   temp = rbind(temp_gene, temp_cell)
   filter_tab = rbind(filter_tab, temp)
   
}

filter_tab = filter_tab %>%
  dplyr::mutate(filter_nbG_remove = no_filter - filter_nbG_keep) %>%
  dplyr::mutate(filter_pMT_remove = filter_nbG_keep - filter_nbG_pMT_keep) %>%
  dplyr::mutate(filter_pRB_remove = filter_nbG_pMT_keep - filter_nbG_pMT_pRB_keep) %>%
  dplyr::mutate(filter_rmMT_remove = filter_nbG_pMT_pRB_keep - filter_nbG_pMT_pRB_rmMT_keep)

filter_tab %>%
  kable() %>%
  kable_styling()
  
```

D'autres filtres pourraient être appliqués sur le jeu de données (ex : écarter des gènes qui monopolisent les reads...).  
Avant d'aller plus loin de ce côté, on continue l'analyse des données pour voir ce qu'il est pertinent d'appliquer ou non. 
  
## Tableau des infos par condition 

Après l'application des filtres : 

```{r}

names(filtered_list_seurat_obj) = names(list_seurat_obj)

summary_tab = data.frame(condition = character(),
                         statistic = character(),
                         nbgenes_per_cell = numeric(),
                         percent_MT_RNA = numeric(),
                         percent_RB_RNA = numeric())

for(i in 1:number_conditions) {
  
  temp = data.frame(condition = rep(names(filtered_list_seurat_obj[i]), 3),
                    statistic = c("min", "median", "max"),
                    nbgenes_per_cell = c(
                      min(filtered_list_seurat_obj[[i]]$nFeature_RNA), 
                      median(filtered_list_seurat_obj[[i]]$nFeature_RNA), 
                      max(filtered_list_seurat_obj[[i]]$nFeature_RNA)),
                    percent_MT_RNA = c(
                      min(filtered_list_seurat_obj[[i]]$percent.mt), 
                      median(filtered_list_seurat_obj[[i]]$percent.mt), 
                      max(filtered_list_seurat_obj[[i]]$percent.mt)),
                    percent_RB_RNA = c(
                      min(filtered_list_seurat_obj[[i]]$percent.ribo), 
                      median(filtered_list_seurat_obj[[i]]$percent.ribo), 
                      max(filtered_list_seurat_obj[[i]]$percent.ribo))
                    )
  summary_tab = rbind(summary_tab, temp)
  
}

summary_tab %>%
  kable() %>%
  kable_styling()

```

*NB : Il serait possible d'appliquer un filtre sur le nombre d'UMI nécessaire par gène pour qu'il ne soit pas considéré comme du bruit de fond ou alors sur le nombre de cellules devant exprimer le gène pour qu'on le conserve mais on a décidé de ne pas le faire pour le moment. Cela évite d'enlever trop d'informations dès le début. Il sera toujours possible d'appliquer ce genre de filtre par la suite si on se rend compte que les données sont biaisées.*

```{r, Save outputs}

ggsave(plot = grid.arrange(grobs = plot_feature_graphs, ncol = 5, nrow = 2, top = textGrob("nFeature_RNA")),
filename = paste0(directory_output, "plot_feature_filter.png"),
width = 16, height = 12)

ggsave(plot = grid.arrange(grobs = unlist(plot_percentage_graphs, recursive = FALSE), 
                           ncol = 6, top = textGrob("Mitochondrial and ribosomal RNA percentages")),
       filename = paste0(directory_output, "plot_percentMTRB_filter.png"),
       width = 24, height = 24)

# Save Seurat object with all filters
saveRDS(list_seurat_obj, file = paste0(directory_output, "list_seurat_obj_qc.rds"))

write.csv2(filter_tab, file = paste0(directory_output, "filter_tab_seurat_obj.csv"))
write.csv2(summary_tab, file = paste0(directory_output, "summary_tab_seurat_obj.csv"))

# saveRDS(list_seurat_obj_obj, file = paste0(directory_output, "list_seurat_obj_each_filter_qc.rds"))

```

```{r, Rsession}

# Clean working space and show package version
rm(list = ls())
sessionInfo()

```








<!-- ## .Gènes détectés par cellules et doublets - Application des filtres -->


<!-- As the ribosomal proteins are highly expressed they will make up a larger proportion of the transcriptional landscape when fewer of the lowly expressed genes are detected.  -->



<!-- ```{r,  fig.width=14, fig.height=6, fig.fullwidth=TRUE} -->
<!-- p1 = VlnPlot(merge_allcond, features = "nFeature_RNA") -->
<!-- p2 = p1 &  -->
<!--   geom_hline(aes(yintercept = 6500), color = "red", size = 1) & -->
<!--   geom_hline(aes(yintercept = 1000), color = "red", size = 1) -->
<!-- p1 | p2 -->
<!-- ``` -->
<!-- Les éléments qui semblent avoir beaucoupl plus de gènes détectés par rapport aux autres cellules peuvent en faite correspondre à des doublets et ceux qui présentant très peu de gènes sont certainement de mauvaise qualité. On applique donc deux filtres qualité pour garder les valeurs les plus qualitatives : les cellules pour lesquelles on détecte **entre 1000 et 6500 gènes**.   -->
<!-- A standard approach is to filter cells with low amount of reads as well as genes that are present in at least a certain amount of cells. Here we will only consider cells with at least 200 detected genes and genes need to be expressed in at least 3 cells.  -->

<!-- ```{r, fig.width=18, fig.height=6, fig.fullwidth=TRUE} -->
<!-- p1 = VlnPlot(merge_allcond, features = "nCount_RNA") -->
<!-- p2 = FeatureScatter(merge_allcond, feature1 = "nCount_RNA", feature2 = "percent.mt") -->
<!-- p3 = FeatureScatter(merge_allcond, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")  -->
<!-- p1 | p2 | p3 -->
<!-- ``` -->
<!-- On observe ici le nombre de transcrits détectés par cellules, is en relation avec le pourcentage d'ARN mitochondrial et le nombre de gènes détectés par cellule. On observe que les cellules avec peu de transcrits détectés présentent pour certaines un fort pourcentage mitochondrial. Elles seront enlevées avec l'application du filtre.      -->


<!-- Additionally, we can also see which genes contribute the most to such reads. We can for instance plot the percentage of counts per gene. -->
<!-- ```{r} -->
<!-- par(mar = c(4, 8, 2, 1)) -->
<!-- C = merge_filter_mtrb@assays$RNA@counts -->
<!-- C <- Matrix::t(Matrix::t(C)/Matrix::colSums(C)) * 100 -->
<!-- # most_expressed <- order(apply(C, 1, median), decreasing = T)[20:1] -->
<!-- boxplot(as.matrix(t(C[most_expressed, ])), cex = 0.1, las = 1, xlab = "% total count per cell", col = (scales::hue_pal())(20)[20:1], horizontal = TRUE) -->
<!-- ``` -->

